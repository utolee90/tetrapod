<img src="https://raw.githubusercontent.com/hmmhmmhm/tetrapod/master/resource/icon.png" alt="icon" width="150"/>

# Tetrapod v2

이 프로젝트는 변형된 욕설 단어를 파악하고 탐지하는 것을 목적으로 하는 모듈로, Github 유저 [hmmhmmhmm의 Tetrapod](https://github.com/hmmhmmhm/tetrapod) 프로젝트를 포크한 뒤에 수정한 모듈입니다. 사용자 Utolee90이 일부 내용을 수정했습니다.

Tetrapod.js 는 변형된 욕설 단어 표현들을 파악하고 탐지하기 위해 개발 되고 있는 모듈형 프로그램입니다. 한국어에서 존재하는 욕설 단어들을 우선적으로 탐지 대상으로 정하여 개발되고 있으며, 향후 모든 언어에서 변형된 욕설 표현을 탐지하는데 사용될 수 있습니다.

## 라이선스

핵심 모듈은 MIT Licensed. 원본의 라이선스를 그대로 따릅니다. 다만 욕설 감지 데이터는 프로그램 활용하는 사람들의 재량에 따라 공개되지 않을 수 있습니다.

## 탐지 알고리즘 설명

Tetrapod.js 에서 사용하는 욕설 탐지 알고리즘의 구성은 다음과 같습니다.

### 정상단어 목록 구성

- `시발점`과 같은 단어의 오탐지를 막기 위해서 사전에 문자열에서 찾아서 욕설 탐지시 탐지대상에서 제외시킬 용도의  정상단어 목록을 구성합니다.

### 욕설단어 목록 구성

- 여러 욕설 단어의 변형을 모두 파악하기 위해서, `음운`, `음절`, `어절` 3단계에 걸쳐서 각 글자 요소들의 변형을 모두 파악하여서 욕설 단어 목록을 구성합니다. 해당 내용은 하단에 Bias 구성란 에서 자세히 설명합니다.

### (추가) 저속한 단어 목록 구성
- 욕설로 분류하기 애매하지만 저속한 표현을 검출할 수 있습니다. 욕설단어와 마찬가지로 단순히 리스트만 쓸 뿐 아니라 이차원 배열을 통한 조합으로도 유도 가능합니다.

### (추가) 특정한 받침을 악용한 단어 검색
- ㅂㅅ, ㄹㅁ, ㄹㄱ 받침을 남용한 표현을 잡아낼 수 있습니다. 

## 프로젝트 상 탐지 알고리즘 구성

Tetrapod.js 에서 사용하는 욕설 탐지 알고리즘의 진행과정은 다음과 같습니다.

### 정상 단어 탐색 후 배제

- 메시지에서 정상단어를 찾아서 해당 문자열의 시작 위치와 끝나는 위치를 기록합니다. 해당 문자열 범위는 이후 알고리즘 탐지시 범위에서 배제됩니다.

### 메시지의 N자단위 분리

- 모든 문자열을 임의의 글자 단위의 **청크 메시지** 로 분리해서 처리할 수 있습니다.  기본 단위는 15자이며, 자세한 것은 아래 API를 참조하세요.

### 한 글자씩 욕설 단어 탐색

- 갖추고 있는 모든 욕설 문자를 글자단위로 모두 분리합니다. 그 후 청크 메시지에 해당 욕설 문자의 글자가 존재하는지, 몇번째 위치에 존재하는지를 파악합니다.
- 만약 문자들이 모두 존재할 경우 해당 문자들의 위치를 해당 욕설 단어의 글자순서대로 정렬합니다. 이때 만약 순서가 일관되지 않다면 글자가 섞여있는 것으로 간주합니다.
- 만약 글자가 섞여있는 경우 욕설 단어의 사이에 완성된 한글 문자가 존재하는지를 확인하고 존재한다면 이를 욕설 목록에서 제외합니다. (`ㄱ`, `ㅙ` 는 완성된 한글이 아니며 완성된 한글은 유니코드로 `가`(0xAC00) ~ `힣`(0xD7A3) 사이의 글자를 뜻합니다.) 또한 완성형 글자이더라도 자음이 `ㅇ` 인경우에는 욕설 예외처리를 하지 않습니다. `예: 바아아보오 와 같이 이어주는 음의 경우 욕설 처리가 필요합니다.`

### 한영자로 된 욕설 탐지 (자체 추가기능)
- 자체적인 한영변환 맵을 이용해서 한/영 변환을 이용한 메시지에도 욕설을 탐지할 수 있습니다. 예를 들면 `wlfkf`이라는 메시지는 QWERTY 영자판에 대응되는 한글 두벌식 자판의 키를 입력하면 `지랄`이라는 메시지가 나타는데, 이러한 욕설을 감지할 수 있습니다.


## 개발 성과
원 프로젝트에서 구현된 목표를 포함합니다. 

- [x] 국립국어원에서의 한국어 정상 단어 목록 확보
- [x] 인터넷 상에서 쓰이는 욕설 데이터 1차 수집
- [x] 문자열 상에서 정상단어를 찾아서 모든 정상단어 위치를 파악하는 알고리즘
- [x] 글자단위 욕설 단어 탐지 알고리즘 
- [x] 뒤집히거나 뒤섞인 욕설 단어 표현의 경우 사람이 인지 가능한 수준만을 욕설로 선정해서 차단하는 알고리즘 추가
- [x] 욕설단어 만을 삭제하거나 특정 특수문자로 대치하는 표현 정정 함수
- [x] 욕설 단어의 변형 예를 `음운`, `음절`, `어절` 3단계로 나누어서 정리해나갈 수 있는 분할된 JSON 기반 파일 데이터 병합 체계
- [x] 배열형태로 단어를 전/후 값으로 나눠서 구성할 수 있는 Bias 데이터 포멧 (예: 바를 `ㅂ/ㅏ` 로 나누어서 표현할 수 있게 하는 체계를 뜻합니다.)
- [x] n차원 형태로 중첩시킬 수 있는 Bias 데이터 포멧 구성 (`바/보` 라는 단어의 변형 예를 모두 구할때, 별도로 존재하는 `ㅂ/ㅏ` 와 `ㅂ/ㅗ` 데이터를 연결시켜서 구성시킬 수 있는 체계를 뜻합니다.)
- [x] n차원의 데이터를 병합할 수 있는 Bias 데이터 포멧
- [x] Bias 데이터 포멧에서의 음절 변수
- [x] Bias 데이터 포멧에서의 응용 함수
- [x] Bias 데이터 포멧에서의 자모합성 함수
- [x] Bias 데이터 포멧에서의 결과배제 함수
- [x] Bias 데이터 포멧에서 테스트 중 중복생선된 단어 탐지 및 삭제 필터
- [ ] Bias 데이터 포멧의 단어 자동 변형 파악 개념 추가 (만능변형인자)
- [ ] 1차 수집된 욕설 데이터의 Bias 재해석
- [ ] Bias 데이터 포멧의 패키지 개념 추가 (욕설단어 / 성적단어 / 폭력성단어 / 약물성단어)
- [ ] LZString 을 통한 Bias 데이터의 minify 화 및 압축 추출 및 메모리 로드 체계
- [ ] 전체 욕설 단어 목록을 사전에 저장하는 형태가 아닌, 욕설 단어 탐지가 발생할때 해당 단어 목록을 실시간으로 구성하여서 쓰다가, 이를 메모리상에 LRU 캐싱 해놓고 씀으로 전체 데이터 용량을 줄이는 동적인 Bias 데이터 해석 체계
- [x] 청크 메시지에서 청크 중간에 욕설이 걸릴 때 감지 보완. (Half-node를 이용해 중간에 노트 끊기로 보완했음.)
- [x] 청크 메시지에서 욕설 단어의 글자가 메시지 상에 있는지 확인할 때 중첩적으로 존재하는 글자가 존재하는 경우, 이를 모두 수집한 후 모든 경우수를 다 계산해서 욕설 검산하는 알고리즘 구현 (부분적으로 구현)
- [ ] 검색엔진 기반 웹 크롤링을 통한 욕설 탐지시도 및 변형단어 수집시도
- [ ] 테스트 페이지 및 테스트 서버 구성
- [ ] gpu.js 쉐이더 기반의 GPU 병렬 연산 가속화 구현 (모든 청크메시지를 숫자 배열화 한 후 코어단에 이를 공유된 메모리 형태로 전달하고, 숫자 배열화 된 욕설 문자들을 코어에게 전달하면 이를 모든 코어 하나하나가 각각의 숫자배열 일치 유무를 파악하는 구조)


## 사용가능한 함수

### Tetrapod.js
find.js 파일에 `import Tetrapod from '../tetrapod';`라고 입력하신 뒤에 다음과 같은 함수를 사용할 수 있습니다. 편의상 클래스 명인 Tetrapod.(함수명) 형식으로 작성하는 것이 좋습니다.

2022년 7월 13일에 Tetrapod 호출 방식을 오브젝트 형식으로 호출하는 방식으로 바꾸었습니다. 사용하실 때에는 `tetrapod = new Tetrapod()`를 입력한 뒤에
`tetrapod.loadFile()`을 이용해서 파일을 불러오면 됩니다. 함수 호출시에도 static 방식이 아닌 오브젝트를 호출하는 방식으로 사용해야 합니다.

- 데이터 파일 불러오기 : `loadFile(
  badWordsPath = badWordDefaultPath,
  normalWordsPath = normalWordDefaultPath,
  macroPath = macroDefaultPath,
  disableAutoParse = true
  ) `
   1. JSON으로부터 데이터 파일을 불러옵니다. 프로젝트 안의 임의의 경로로 지정할 수 있습니다.
   1. `loadFile()` 단독으로 호출할 경우 기본 경로인 `./resource/dictionary` 경로 하의 JSON 파일로부터 호출합니다. 

- 비속어 수준 조절: `Tetrapod.adjustFilter(level, type)`
  1. 비속어의 수위와 타입을 표현하게 할 수 있습니다. 
  1. `level` 변수는 리스트 형식으로 `[0,1,2,3,4]`의 부분집합 리스트를 입력해야 합니다.
  1. `type` 변수는 리스트 형식으로 약물(drug), 모욕적 표현(insult), 성적(sexuality), 폭력적(violence) 코드 중에 단어 유형을 표시할 타입 목록을 설명합니다. 기본값은 `[]`로 아무 타입도 찾아내지 않습니다.

- 비속어 존재 여부 판단 : `Tetrapod.isBad(message, includeSoft=false)`
  1. message 항에는 문자열을 입력해서 사용 가능합니다. 결과값은 참/거짓 중 하나. 
  1. includeSoft 부분에 true를 입력하면 비속어뿐 아니라 저속한 표현, 부적절한 받침을 남용하는 표현까지 존재하는지 체크할 수 있습니다.
    
- 비속어 갯수 세기 : `Tetrapod.countBad(message, isStrong=false)`
  1. message 항에는 문자열을 입력해서 사용 가능합니다. 
  1. 결과값은 `{bad:(비속어 갯수),soft:(저속한 표현 갯수),end:(부적절한 받침 갯수)} ` 형식으로 출력됩니다.
  1. `isStrong`값을 참으로 지정하면 다른 문자를 한글자모처럼 이용해서 우회적 표현이나 (예: `ㄱH새77|`) 첫 자음 ㅇ, 무의미한 모음 ㅡ삽입 및 된소리를 이용한 우회표현(`브아보 썌끼`)도 잡아낼 수 있습니다.   

- 비속어 표현 직접 찾기 : `Tetrapod.find(message, needMultipleCheck=false, splitCheck=15, qwertyToDubeol=false, stronger=false)`
  1. message 항에는 문자열을 직접 입력해서 사용가능합니다.
  1. 결과값은 `{totalResult:[(비속어 단어 목록)], softResult:[(저속한 표현 단어 목록)], endResult:[(받침 악용한 표현 목록)]}` 형식의 오브젝트로 출력됩니다.
  1. `needMultiplecheck`를 true로 지정하면 필터에 걸리는 모든 표현을 잡아낼 수 있습니다. 
  1. `splitCheck`를 임의의 숫자(예 20)로 지정하면 지정한 숫자만큼 문자열을 나눈 뒤 나눈 조각들만 조사합니다. 기본값은 15이며, 0을 지정하면 문자열을 나누지 않고 전체 문자열을 검사합니다. isStrong을 지정하면 활성화되지 않습니다.
  1. `qwertyToDubeol`를 true로 지정하면 한/영전환된 표현을 잡아낼 수 있습니다. 예를 들면 `시발`의 QWERTY에 대응되는 표현인 `tlqkf`을 잡아낼 수 있습니다.
  1. `isStrong`을 true로 지정하면 다른 문자를 한글자모처럼 이용하는 우회적 표현이나 첫자음 ㅇ, 무의미한 모음 ㅡ삽입 및 된소리를 이용한 우회 표현도 잡아낼 수 있습니다. 영자를 한글로 변화해서 검사하는 특성상 위의 `qwertyToDubeol`와 같이 사용할 수 없습니다.
  
- 비속어 표현 숨기기 : `Tetrapod.fix(message, replaceCharacter, condition)` 형태로 사용합니다. 
  1. message 항에는 욕설이 들어간 문자열을 직접 입력해서 사용 가능합니다. 
  1. replaceCharacter 항에는 욕설을 숨길 때 사용하는 문자를 지정할 수 있습니다. 기본값은 "*"입니다.
  1. condition 항에는 qwertyToDubeol, antispoof, dropDouble 옵션 중 하나를 켤 수 있습니다. 기본은 `{qwertyToDubeol:false, antispoof:false, dropDouble:false, fixSoft:false}`으로 모두 비활성화된 상태입니다.
  1. 현재는 condition에 옵션을 켤 경우 qwertyToDubeol(qwerty자판->두벌식 자판으로 한영변환 후 테스트), antispoof(유사자음, 유사모음 전부 자모로 바꾼 후 테스트), dropDouble(ㅇ 들어가서 음 늘리기 등 잡아냄)으로 바뀐 후에 잡아낸 메시지만 체크 가능합니다. 원문에서 교정하는 옵션은 현재 불가능합니다.
  1. condition 조건에 `{fixSoft:true}`라고 지정할 경우 비속어 뿐 아니라 저속한 표현과 과도한 겹받침 표현도 숨김처리가 가능합니다.
  
- 파싱한 비속어 표현 리스트 저장하기 : `Tetrapod.defaultSaveAllData`를 사용하시면 됩니다. 
  
#### JSON 파일 작성방법
기본적으로 `./resource/dictionary` 디렉토리에 있는 `bad-words.json`, `normal-words.json`, `macros.json` 이 세 파일을 검사합니다. 

- `bad-words.json` - 예상되는 비속어를 저장합니다. 비속어 수준에 따라 badWords, badWordsOne, badWordsTwo, badWordsThree, badWordsFour로 나누었습니다. 파싱할 때 recursiveComponenent 메소드를 이용하기에 `[['바','ba'],['보','bo']]`처럼 앞단어/뒷단어로 구성된 구성요소도 작성 가능합니다. 
  - `badWords` : 기본 비속어 목록
  - `badWordsOne`, `badWordsTwo`, `badWordsThree`, `badWordsFour` : 비속어 수준에 따라 지정할 수 있습니다.
  - `drug` : 약물 관련 비속어 목록
  - `insult` : 모욕적인 표현 관련 비속어 목록
  - `sexuality` : 성적인 표현 관련 비속어 목록
  - `violence` : 폭력적 표현 관련 비속어 목록
  - `macro` : 특정 반복되는 패턴들을 저장할 수 있습니다. 저장할 때는 `"매크로명":[(매크로에 포함된 리스트)]` 형식으로 사용하시면 되며, 매크로를 사용할 때에는 매크로 이름 앞에 "*"표시를 붙이면 됩니다. 
    + 매크로 예시 : `{놈:["놈", "뇸", "넘", "롬", "룜", "럼"]}`
    + `badword` 입력할 때 `[[["개", "멍청한"], ["*놈"]]]`
    + 파싱 결과 :
  ```json
  [
    "개놈",
    "개뇸",
    "개넘",
    "개롬",
    "개룜",
    "개럼",
    "멍청한놈",
    "멍청한뇸",
    "멍청한넘",
    "멍청한롬",
    "멍청한룜",
    "멍청한럼"
  ]

- `normal-words.json` - 예상되는 정상 단어를 저장합니다. tetrapod 프로젝트는 메시지에서 정상단어로 예상되는 위치에서는 검사하지 않는 방식입니다. 정상단어에 모욕적 표현이 붙은 경우 이 부분을 감지하지 않기 위한 예외 목록을 추가하려면 `exception` 부분에 리스트를 추가하시면 됩니다.
- `macros.json` - 반복되는 표현을 입력할 때 사용합니다. badWord에서 사용할 때에는 `*(매크로명)` 형태로 사용할 수 있습니다.

#### 작성용 기호
한글 단어 이외에 `*, !`등을 사용할 수 있습니다. 사용하는 방법은 다음과 같습니다.
- 매크로용 문자. 앞에서 붙일 때에만 쓸 수 있습니다.
  - `*` 매크로 사용할 때 사용할 수 있습니다. 주의할 점은 매크로 이름은 띄어쓰기를 해서는 안 되며, 리스트에 독립된 단어 형식으로 들어가야 합니다.
- 대체 문자 - 글자 뒤에 문자를 사용합니다. 글자 하나만 사용할 수 있습니다.
  - `!` 앞에 오는 글자에 대해 변형패턴들을 모두 감지합니다. `Tetrapod.isKindChar` 함수를 이용해서 변형 패턴을 잡아낼 수 있습니다. 예를 들면 `시!`의 경우 `ㅅ`의 된소리인 `ㅆ`이나 `ㅣ`와 발음이 유사한 이중모음인 `ㅟ`, `ㅢ`로 변형된 글자도 잡아낼 수 있습니다.
  - `+` 임의의 받침을 표현할 때 사용합니다. 예를 들면 "시+"는 "시,식,싟,..."등을 모두 포함합니다.
- 이스케이프 문자 - 특수 기호를 따로 표현하고자 할 때 사용합니다. 
  - `,` Tetrapod는 한글자모가 따로 떨어져 있으면 자동으로 합성을 해서 처리합니다. 즉, 비속어 리스트에 ["ㄱㅣ레ㄱㅣ"]라고 입력하면 "기레기"를 비속어로 인식합니다. 구태여 원래의 표현인 "ㄱㅣ레ㄱㅣ"를 인식하기 위해서는 "ㄱ,ㅣ레ㄱ,ㅣ"라고 입력하시면 됩니다.
  - `.` 위의 특수문자가 포함된 리스트를 작성하고 싶을 때 사용하는 이스케이프 문자입니다. 예를 들면 "기!" 자체를 비속어로 인식하고 싶을 때는 "기.!"이라고 입력하시면 됩니다.
- 20220713 업데이트로 아무개 문자는 사용이 불가능합니다. 


### Bias.js (삭제 예정)
find.js 파일에 `import Bias from '../bias/bias';`를 입력하신 뒤에 
`Bias.buildHelper('(패키지명)', '(원본 단어명)', false)`를 입력하시면 사용가능합니다. JSON 파일은 bias/build에 저장됩니다.

Tetrapod 프로젝트에서 시간 단축을 위해 유사단어를 매핑하는 방식보다는 영어->한글 전환이나 파서 문자를 이용해 검출하는 방식을 사용할 예정입니다. 

#### 패키지 제작 및 사용 방법 (삭제 예정)
Tetrapod 프로젝트는 기본적으로 `kr-badword` 패키지를 지원하고 있습니다. 그러나 
Bias.js 파일을 이용하면 사용자가 원하는 대로 변형 패턴을 지정할 수 있습니다. 

 1. 우선 `bias/source` 디렉토리에 패키지명으로 디렉토리를 제작합니다. 
 1. 그 다음 아래 포맷 규칙을 이용해서 JSON 파일을 작성합니다.

#### Bias 데이터 포멧(삭제 예정)

- 욕설 단어는 음운마다 발음이 약간씩 달라지거나 모양이 약간씩 달라지는 변형 단어가 파생될 수 있으므로, 각 음운별로 모든 변형 가능한 조합을 알아내야할 필요가 있습니다. 이를 명확하게 파악하기 위해서 모든 음운과 음절, 어절에 쓰일 수 있는 구조를 1차원 배열 또는 2차원 배열로 표현하여서 변형구조를 어절단계에서 파악할 수 있는 어떠한 데이터 구조가 필요합니다. 이를 위해서 개발된 데이터 구조가 Bias 데이터 포멧입니다.

#### RecursiveList

- Bias 데이터 포멧은 필터에 사용될 욕설를 2차원 배열을 중첩해나가면서 조합될 단어의 목록을 구성할 수 있게 돕습니다. 2차원 배열은 before+after 구조로, 각 차원 데이터가 합쳐져서 단어를 구성하게 됩니다. 이를 RecursiveList 라고 하며 다음과 같은 예시형태로 구성될 수 있습니다.

##### 2차원 배열 예시

```javascript
let data = [[
    "바",
    "ba"
],[
    "보",
    "bo"
]]
let result = Bias.recursiveList(data)
let resultCheck = [
    "바보",
    "바bo",
    "ba보",
    "babo"
]
console.log(result == resultCheck)
// true
```

##### 중첩된 2차원 배열 예시

RecursiveList 로는 자음과 모음의 변형과정을 세분화해서 명시하는데 적합한 구조를 갖추고 있습니다. 하지만 자음 모음을 합성해서 완성된 한글문자로 합친다던지, 자음과 모음을 재활용할 수 있는 어떠한 구조는 RecursiveComponent 에서 다룹니다.

```javascript
let data = [[
    [[
        'ㅂ',
        'ㅃ'
    ],[
        'ㅏ',
        'ㅑ'
    ]],
    "ba"
],[
    "보",
    "bo"
]]
let result = Bias.recursiveList(data)
let resultCheck = [
    "ㅂㅏ보",
    "ㅂㅑ보",
    "ㅃㅏ보",
    "ㅃㅑ보",
    "ㅂㅏbo",
    "ㅂㅑbo",
    "ㅃㅏbo",
    "ㅃㅑbo",
    "ba보",
    "babo"
]
console.log(result == resultCheck)
// true
```

#### RecursiveComponent (미완성)

RecursiveComponent 는 RecursiveList 의 재사용성을 높이고 배열 상에서 사용가능한 부가적인 함수개념을 제공합니다.

##### 변수 및 코드 분리

RecursiveComponent 는 `변수`와 `코드`가 존재하며, 자음과 모음 같이 한글문자의 최소 단위인  `음운` 을 RecursiveList 로 표현할 때 재활용성을 높이기 위해서 `변수`를 사용하며, 해당 `음운`들로 어떠한 최종적인 `음절`을 구성할 때 `코드` 를 구성합니다.

##### 자유로운 JSON 파일구성

RecursiveComponent 를 구성할 때 한국어의 경우 `음운`, `음절`, `어절` 의 형태로 구성될 수 있지만, 향후 개발 과정에서 새로운구조가 필요하거나, 차후 다른 언어에 확장형태로 다른 구조를 취해야할 가능성이 있기에, 보다 유연하게 데이터를 분리해야할 필요가 있습니다. 이를 위해서 JSON 형태로 데이터를 표현할 수 있게 허용하고 있으며, JSON 데이터는 해당 소스폴더 안에만 있다면 내부에 얼마나 중첩된 폴더아래에 JSON파일이 존재하던, 어떤 이름으로 폴더가 존재하던, 어떤 이름으로 JSON 파일이 존재하던 이를 모두 수집해서 구성할 수 있게끔 RecursiveComponent 를 구성하였고, 이를 통해서 자유롭게 데이터 명칭 부여를 하고 자유로운 데이터 카테고리 부여가 가능합니다.

##### JSON내에서의 변수 구성 예

JSON 에서 객체를 하나 생성후 그 안에 `var` 라는 이름의 객체를 하나 담으면, 그 `var` 객체 안에 변수를 생성할 수 있습니다. 한국어 데이터의 경우엔 이를 통해서 `음운` 데이터를 구성하며, 이 과정에서 한 `음운`의 `발음변형` 과 `모양변형` 데이터를 RecursiveComponent 로 모두 구성합니다. 이렇게 구성된 `ㅂ` 의 음운 데이터화 예시는 다음과 같습니다.

```json
{
    "var": {
        "ㅂ_발음변형": [
            "ㅂ",
            "ㅃ",
            "ㅍ"
        ],
        "ㅂ_모양변형": [
            "ㅂ",
            "ㅃ",
            "ㅍ",
            "b",
            "f"
        ]
    }
}
```

##### JSON내에서 변수 간 참조

JSON 형태로 Bias 데이터를 구성할 때 변수를 구성할 수 있는데, 이 변수 내에서 다른 변수를 써야하는 상황이 생길 수 있습니다. 한국어는 주로 `음절` 데이터 구성시 `음운` 변수를 불러와야함과 동시에 자신도 변수여야하는 상황이 발생하는데, 이런 상황을 위해서 변수가 변수를 참조할 수 있도록 구성되어 있습니다. 변수는 RecursiveList 를 사용할때 요소 앞에 `*`를 붙여서 사용하면 해당 위치에 변수 데이터가 참조됩니다. `음절` 데이터 구성 시 자음과 모음을 합쳐서 완성된 한글 글자를 만들어야하는 경우가 생기는데, 이럴 때를 위한 `자모합성` 함수기능 또한 구현되어 있습니다. 자모를 합성해서 완성된 한글 글자를 만들지 않고 자모를 각각 분리된 글자처럼 취급하는 것은 `단어병합` 함수 라고 합니다. 기본적으로 RecursiveList 는 `단어병합` 알고리즘으로 작동되지만, `자모합성`과 차이를 명확하게 하기 위해서 함수명을 표기해서 구분할 수 있습니다.

##### 변수간 참조 및 함수 사용 예

```json
{
    "var": {
        "시": [
            {
                "type": "단어병합",
                "data": [[
                    "*ㅅ_모양변형"
                ], [
                    ""
                ]]
            },

            {
                "type": "자모합성",
                "data": [
                    [
                        "ㅅ",
                        "ㅆ"
                    ], [
                        "*ㅣ_발음변형"
                    ]
                ],
                "exclude": ["쇠"]
            }
        ]
    }
}
```

##### 단어병합 함수 및 코드 구성 예

`code` 는 변수를 사용해서 최종적으로 정의될 데이터를 정의하는 공간입니다. 한글에서는 `어절` 을 정리할 때 사용됩니다. 최종적으로 산출된 결과물 중 배제하고 싶은 단어를 `exclude` 부분에 입력해주면 해당 단어는 결과물에서 삭제된채로 반환됩니다.

```json
{
    "code": [

        {
            "type": "단어병합",
            "data": [[
                "*바"
            ],[
                "*보"
            ]],
            "exclude": [
                "babo"
            ]
        }

    ]
}
```

#### 주의사항

##### 단어병합시 주의사항

- 단어병합 함수는 한글 글자 자모에 각각 한글자씩을 할당해서 병합하는 함수를 뜻합니다. (예: ㅂㅏㅂㅗ-> ㅂㅏㅂㅗ)
- 자음만으로 욕설가 될 수 있는 욕설의 경우엔 단어병합시 모음을 절대 추가로 표기하지 않습니다.
- 불필요한 모음을 추가하면 불필요한 용량증가와 처리속도 지연을 불러옵니다.

##### 자모합성시 주의사항

- 자모합성 함수는 한글 글자 자모를 최대한 한글자로 몰아서 병합하는 함수를 뜻합니다. (예: ㅂㅏㅂㅗ-> 바보)
- `ㅂㅗㅑ` 와 같이 한글자로 합성될 수 없는 단어 합성을 절대적으로 피해야합니다.
