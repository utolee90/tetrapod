<img src="https://raw.githubusercontent.com/hmmhmmhm/tetrapod/master/resource/icon.png" alt="icon" width="150"/>

# Tetrapod.js var1

이 프로젝트는 변형된 욕설 단어를 파악하고 탐지하는 것을 목적으로 하는 모듈로, Github 유저 [hmmhmmhmm의 Tetrapod](https://github.com/hmmhmmhm/tetrapod) 프로젝트를 포크한 뒤에 수정한 모듈입니다. 사용자 Utolee90이 일부 내용을 수정했습니다.

Tetrapod.js 는 변형된 욕설 단어 표현들을 파악하고 탐지하기 위해 개발 되고 있는 모듈형 프로그램입니다. 한국어에서 존재하는 욕설 단어들을 우선적으로 탐지 대상으로 정하여 개발되고 있으며, 향후 모든 언어에서 변형된 욕설 표현을 탐지하는데 사용될 수 있습니다.

## 프로젝트 용도
이 프로젝트는 (주)클레온에서 제공하는 영상 공유 SNS [Kamelo](https://kamelo.io/) 에서 활용할 예정입니다.

## 라이센스

핵심 모듈은 MIT Licensed. 원본의 라이선스를 그대로 따릅니다. 다만 욕설 감지 데이터는 보안사항으로 공개되지 않을 예정입니다. 


## 프로젝트 상 탐지 알고리즘 구성

Tetrapod.js 에서 사용하는 욕설 탐지 알고리즘의 구성은 다음과 같습니다.

### 정상단어 목록 구성

- `시발점`과 같은 단어의 오탐지를 막기 위해서 사전에 문자열에서 찾아서 욕설 탐지시 탐지대상에서 제외시킬 용도의  정상단어 목록을 구성합니다.

### 욕설단어 목록 구성

- 여러 욕설 단어의 변형을 모두 파악하기 위해서, `음운`, `음절`, `어절` 3단계에 걸쳐서 각 글자 요소들의 변형을 모두 파악하여서 욕설 단어 목록을 구성합니다. 해당 내용은 하단에 Bias 구성란 에서 자세히 설명합니다.

### (추가) 저속한 단어 목록 구성
- 욕설로 분류하기 애매하지만 저속한 표현을 검출할 수 있습니다. 욕설단어와 마찬가지로 단순히 리스트만 쓸 뿐 아니라 이차원 배열을 통한 조합으로도 유도 가능합니다.

### (추가) 특정한 받침을 악용한 단어 검색
- ㅂㅅ, ㄹㅁ, ㄹㄱ 받침을 남용한 표현을 잡아낼 수 있습니다. 

## 프로젝트 상 탐지 알고리즘 구성

Tetrapod.js 에서 사용하는 욕설 탐지 알고리즘의 진행과정은 다음과 같습니다.

### 정상 단어 탐색 후 배제

- 메시지에서 정상단어를 찾아서 해당 문자열의 시작 위치와 끝나는 위치를 기록합니다. 해당 문자열 범위는 이후 알고리즘 탐지시 범위에서 배제됩니다.

### 메시지의 N자단위 분리

- 모든 문자열을 임의의 글자 단위의 **청크 메시지** 로 분리해서 처리할 수 있습니다.  기본 단위는 15자이며, 자세한 것은 아래 API를 참조하세요.

### 한 글자씩 욕설 단어 탐색

- 갖추고 있는 모든 욕설 문자를 글자단위로 모두 분리합니다. 그 후 청크 메시지에 해당 욕설 문자의 글자가 존재하는지, 몇번째 위치에 존재하는지를 파악합니다.
- 만약 문자들이 모두 존재할 경우 해당 문자들의 위치를 해당 욕설 단어의 글자순서대로 정렬합니다. 이때 만약 순서가 일관되지 않다면 글자가 섞여있는 것으로 간주합니다.
- 만약 글자가 섞여있는 경우 욕설 단어의 사이에 완성된 한글 문자가 존재하는지를 확인하고 존재한다면 이를 욕설 목록에서 제외합니다. (`ㄱ`, `ㅙ` 는 완성된 한글이 아니며 완성된 한글은 유니코드로 `가`(0xAC00) ~ `힣`(0xD7A3) 사이의 글자를 뜻합니다.) 또한 완성형 글자이더라도 자음이 `ㅇ` 인경우에는 욕설 예외처리를 하지 않습니다. `예: 바아아보오 와 같이 이어주는 음의 경우 욕설 처리가 필요합니다.`

### 한영자로 된 욕설 탐지 (자체 추가기능)
- 자체적인 한영변환 맵을 이용해서 한/영 변환을 이용한 메시지에도 욕설을 탐지할 수 있습니다. 예를 들면 `wlfkf`이라는 메시지는 QWERTY 영자판에 대응되는 한글 두벌식 자판의 키를 입력하면 `지랄`이라는 메시지가 나타는데, 이러한 욕설을 감지할 수 있습니다.   

### Bias 데이터 포멧(미완성)

- 욕설 단어는 음운마다 발음이 약간씩 달라지거나 모양이 약간씩 달라지는 변형 단어가 파생될 수 있으므로, 각 음운별로 모든 변형 가능한 조합을 알아내야할 필요가 있습니다. 이를 명확하게 파악하기 위해서 모든 음운과 음절, 어절에 쓰일 수 있는 구조를 1차원 배열 또는 2차원 배열로 표현하여서 변형구조를 어절단계에서 파악할 수 있는 어떠한 데이터 구조가 필요합니다. 이를 위해서 개발된 데이터 구조가 Bias 데이터 포멧입니다.

#### RecursiveList

- Bias 데이터 포멧은 필터에 사용될 욕설를 2차원 배열을 중첩해나가면서 조합될 단어의 목록을 구성할 수 있게 돕습니다. 2차원 배열은 before+after 구조로, 각 차원 데이터가 합쳐져서 단어를 구성하게 됩니다. 이를 RecursiveList 라고 하며 다음과 같은 예시형태로 구성될 수 있습니다.

##### 2차원 배열 예시

```javascript
let data = [[
    "바",
    "ba"
],[
    "보",
    "bo"
]]
let result = Bias.recursiveList(data)
let resultCheck = [
    "바보",
    "바bo",
    "ba보",
    "babo"
]
console.log(result == resultCheck)
// true
```

##### 중첩된 2차원 배열 예시

RecursiveList 로는 자음과 모음의 변형과정을 세분화해서 명시하는데 적합한 구조를 갖추고 있습니다. 하지만 자음 모음을 합성해서 완성된 한글문자로 합친다던지, 자음과 모음을 재활용할 수 있는 어떠한 구조는 RecursiveComponent 에서 다룹니다.

```javascript
let data = [[
    [[
        'ㅂ',
        'ㅃ'
    ],[
        'ㅏ',
        'ㅑ'
    ]],
    "ba"
],[
    "보",
    "bo"
]]
let result = Bias.recursiveList(data)
let resultCheck = [
    "ㅂㅏ보",
    "ㅂㅑ보",
    "ㅃㅏ보",
    "ㅃㅑ보",
    "ㅂㅏbo",
    "ㅂㅑbo",
    "ㅃㅏbo",
    "ㅃㅑbo",
    "ba보",
    "babo"
]
console.log(result == resultCheck)
// true
```

#### RecursiveComponent (미완성)

RecursiveComponent 는 RecursiveList 의 재사용성을 높이고 배열 상에서 사용가능한 부가적인 함수개념을 제공합니다.

##### 변수 및 코드 분리

RecursiveComponent 는 `변수`와 `코드`가 존재하며, 자음과 모음 같이 한글문자의 최소 단위인  `음운` 을 RecursiveList 로 표현할 때 재활용성을 높이기 위해서 `변수`를 사용하며, 해당 `음운`들로 어떠한 최종적인 `음절`을 구성할 때 `코드` 를 구성합니다.

##### 자유로운 JSON 파일구성

RecursiveComponent 를 구성할 때 한국어의 경우 `음운`, `음절`, `어절` 의 형태로 구성될 수 있지만, 향후 개발 과정에서 새로운구조가 필요하거나, 차후 다른 언어에 확장형태로 다른 구조를 취해야할 가능성이 있기에, 보다 유연하게 데이터를 분리해야할 필요가 있습니다. 이를 위해서 JSON 형태로 데이터를 표현할 수 있게 허용하고 있으며, JSON 데이터는 해당 소스폴더 안에만 있다면 내부에 얼마나 중첩된 폴더아래에 JSON파일이 존재하던, 어떤 이름으로 폴더가 존재하던, 어떤 이름으로 JSON 파일이 존재하던 이를 모두 수집해서 구성할 수 있게끔 RecursiveComponent 를 구성하였고, 이를 통해서 자유롭게 데이터 명칭 부여를 하고 자유로운 데이터 카테고리 부여가 가능합니다.

##### JSON내에서의 변수 구성 예

JSON 에서 객체를 하나 생성후 그 안에 `var` 라는 이름의 객체를 하나 담으면, 그 `var` 객체 안에 변수를 생성할 수 있습니다. 한국어 데이터의 경우엔 이를 통해서 `음운` 데이터를 구성하며, 이 과정에서 한 `음운`의 `발음변형` 과 `모양변형` 데이터를 RecursiveComponent 로 모두 구성합니다. 이렇게 구성된 `ㅂ` 의 음운 데이터화 예시는 다음과 같습니다.

```json
{
    "var": {
        "ㅂ_발음변형": [
            "ㅂ",
            "ㅃ",
            "ㅍ"
        ],
        "ㅂ_모양변형": [
            "ㅂ",
            "ㅃ",
            "ㅍ",
            "b",
            "f"
        ]
    }
}
```

##### JSON내에서 변수 간 참조

JSON 형태로 Bias 데이터를 구성할 때 변수를 구성할 수 있는데, 이 변수 내에서 다른 변수를 써야하는 상황이 생길 수 있습니다. 한국어는 주로 `음절` 데이터 구성시 `음운` 변수를 불러와야함과 동시에 자신도 변수여야하는 상황이 발생하는데, 이런 상황을 위해서 변수가 변수를 참조할 수 있도록 구성되어 있습니다. 변수는 RecursiveList 를 사용할때 요소 앞에 `*`를 붙여서 사용하면 해당 위치에 변수 데이터가 참조됩니다. `음절` 데이터 구성 시 자음과 모음을 합쳐서 완성된 한글 글자를 만들어야하는 경우가 생기는데, 이럴 때를 위한 `자모합성` 함수기능 또한 구현되어 있습니다. 자모를 합성해서 완성된 한글 글자를 만들지 않고 자모를 각각 분리된 글자처럼 취급하는 것은 `단어병합` 함수 라고 합니다. 기본적으로 RecursiveList 는 `단어병합` 알고리즘으로 작동되지만, `자모합성`과 차이를 명확하게 하기 위해서 함수명을 표기해서 구분할 수 있습니다. 

##### 변수간 참조 및 함수 사용 예

```json
{
    "var": {
        "시": [
            {
                "type": "단어병합",
                "data": [[
                    "*ㅅ_모양변형"
                ], [
                    ""
                ]]
            },

            {
                "type": "자모합성",
                "data": [
                    [
                        "ㅅ",
                        "ㅆ"
                    ], [
                        "*ㅣ_발음변형"
                    ]
                ],
                "exclude": ["쇠"]
            }
        ]
    }
}
```

##### 단어병합 함수 및 코드 구성 예

`code` 는 변수를 사용해서 최종적으로 정의될 데이터를 정의하는 공간입니다. 한글에서는 `어절` 을 정리할 때 사용됩니다. 최종적으로 산출된 결과물 중 배제하고 싶은 단어를 `exclude` 부분에 입력해주면 해당 단어는 결과물에서 삭제된채로 반환됩니다.

```json
{
    "code": [

        {
            "type": "단어병합",
            "data": [[
                "*바"
            ],[
                "*보"
            ]],
            "exclude": [
                "babo"
            ]
        }

    ]
}
```

#### 주의사항

##### 단어병합시 주의사항

- 단어병합 함수는 한글 글자 자모에 각각 한글자씩을 할당해서 병합하는 함수를 뜻합니다. (예: ㅂㅏㅂㅗ-> ㅂㅏㅂㅗ)
- 자음만으로 욕설가 될 수 있는 욕설의 경우엔 단어병합시 모음을 절대 추가로 표기하지 않습니다.
- 불필요한 모음을 추가하면 불필요한 용량증가와 처리속도 지연을 불러옵니다.

##### 자모합성시 주의사항

- 자모합성 함수는 한글 글자 자모를 최대한 한글자로 몰아서 병합하는 함수를 뜻합니다. (예: ㅂㅏㅂㅗ-> 바보)
- `ㅂㅗㅑ` 와 같이 한글자로 합성될 수 없는 단어 합성을 절대적으로 피해야합니다.


## 개발 성과
원 프로젝트에서 구현된 목표를 포함합니다. 

- [x] 국립국어원에서의 한국어 정상 단어 목록 확보
- [x] 인터넷 상에서 쓰이는 욕설 데이터 1차 수집
- [x] 문자열 상에서 정상단어를 찾아서 모든 정상단어 위치를 파악하는 알고리즘
- [x] 글자단위 욕설 단어 탐지 알고리즘 
- [x] 뒤집히거나 뒤섞인 욕설 단어 표현의 경우 사람이 인지 가능한 수준만을 욕설로 선정해서 차단하는 알고리즘 추가
- [x] 욕설단어 만을 삭제하거나 특정 특수문자로 대치하는 표현 정정 함수
- [x] 욕설 단어의 변형 예를 `음운`, `음절`, `어절` 3단계로 나누어서 정리해나갈 수 있는 분할된 JSON 기반 파일 데이터 병합 체계
- [x] 배열형태로 단어를 전/후 값으로 나눠서 구성할 수 있는 Bias 데이터 포멧 (예: 바를 `ㅂ/ㅏ` 로 나누어서 표현할 수 있게 하는 체계를 뜻합니다.)
- [x] n차원 형태로 중첩시킬 수 있는 Bias 데이터 포멧 구성 (`바/보` 라는 단어의 변형 예를 모두 구할때, 별도로 존재하는 `ㅂ/ㅏ` 와 `ㅂ/ㅗ` 데이터를 연결시켜서 구성시킬 수 있는 체계를 뜻합니다.)
- [x] n차원의 데이터를 병합할 수 있는 Bias 데이터 포멧
- [x] Bias 데이터 포멧에서의 음절 변수
- [x] Bias 데이터 포멧에서의 응용 함수
- [x] Bias 데이터 포멧에서의 자모합성 함수
- [x] Bias 데이터 포멧에서의 결과배제 함수
- [x] Bias 데이터 포멧에서 테스트 중 중복생선된 단어 탐지 및 삭제 필터
- [ ] Bias 데이터 포멧의 단어 자동 변형 파악 개념 추가 (만능변형인자)
- [ ] 1차 수집된 욕설 데이터의 Bias 재해석
- [ ] Bias 데이터 포멧의 패키지 개념 추가 (욕설단어 / 성적단어 / 폭력성단어 / 약물성단어)
- [ ] LZString 을 통한 Bias 데이터의 minify 화 및 압축 추출 및 메모리 로드 체계
- [ ] 전체 욕설 단어 목록을 사전에 저장하는 형태가 아닌, 욕설 단어 탐지가 발생할때 해당 단어 목록을 실시간으로 구성하여서 쓰다가, 이를 메모리상에 LRU 캐싱 해놓고 씀으로 전체 데이터 용량을 줄이는 동적인 Bias 데이터 해석 체계
- [ ] 청크 메시지의 15자->30자 확대 및, 청크 메시지가 연속될 경우, 중간의 15자끼리 이어서 새로운 청크메시지를 임의로 만들어서 검사를 돌리는 보완체계 (청크 메시지 사이에 걸려서 필터링 되지 않는 예외 상황 해결)
- [ ] 청크 메시지에서 욕설 단어의 글자가 메시지 상에 있는지 확인할 때 중첩적으로 존재하는 글자가 존재하는 경우, 이를 모두 수집한 후 모든 경우수를 다 계산해서 욕설 검산하는 알고리즘 구현
- [ ] 검색엔진 기반 웹 크롤링을 통한 욕설 탐지시도 및 변형단어 수집시도
- [ ] 테스트 페이지 및 테스트 서버 구성
- [ ] gpu.js 쉐이더 기반의 GPU 병렬 연산 가속화 구현 (모든 청크메시지를 숫자 배열화 한 후 코어단에 이를 공유된 메모리 형태로 전달하고, 숫자 배열화 된 욕설 문자들을 코어에게 전달하면 이를 모든 코어 하나하나가 각각의 숫자배열 일치 유무를 파악하는 구조)


## 사용가능한 함수

### Tetrapod.js
find.js 파일에 `import Tetrapod from '../tetrapod';`라고 입력하신 뒤에 다음과 같은 함수를 사용할 수 있습니다. 편의상 클래스 명인 Tetrapod.(함수명) 형식으로 작성하는 것이 좋습니다.

- 비속어 존재 여부 판단 : `Tetrapod.isBad(message, includeSoft=false)`
  1. message 항에는 문자열을 입력해서 사용 가능합니다. 결과값은 참/거짓 중 하나. 
  1. includeSoft 부분에 true를 입력하면 비속어뿐 아니라 저속한 표현, 부적절한 받침을 남용하는 표현까지 존재하는지 체크할 수 있습니다.
    
- 비속어 갯수 세기 : `Tetrapod.countBad(message, isStrong=false)`
  1. message 항에는 문자열을 입력해서 사용 가능합니다. 
  1. 결과값은 `{bad:(비속어 갯수),soft:(저속한 표현 갯수),end:(부적절한 받침 갯수)} ` 형식으로 출력됩니다.
  1. `isStrong`값을 참으로 지정하면 다른 문자를 한글자모처럼 이용해서 우회적 표현이나 (예: `ㄱH새77|`) 첫 자음 ㅇ, 무의미한 모음 ㅡ삽입 및 된소리를 이용한 우회표현(`브아보 썌끼`)처럼 도 잡아낼 수 있습니다.   

- 비속어 표현 직접 찾기 : `Tetrapod.find(message, needMultipleCheck=false, splitCheck=15, needEnToKo=false, stronger=false)`
  1. message 항에는 문자열을 직접 입력해서 사용가능ㅎ바니다.
  1. 결과값은 `{totalResult:[(비속어 단어 목록)], softResult:[(저속한 표현 단어 목록)], endResult:[(받침 악용한 표현 목록)]}` 형식의 오브젝트로 출력됩니다.
  1. `needMultiplecheck`를 true로 지정하면 필터에 걸리는 모든 표현을 잡아낼 수 있습니다. 
  1. `splitCheck`를 임의의 숫자(예 20)로 지정하면 지정한 숫자만큼 문자열을 나눈 뒤 나눈 조각들만 조사합니다. 기본값은 15이며, 0을 지정하면 문자열을 나누지 않고 전체 문자열을 검사합니다.
  1. `needEnToKo`를 true로 지정하면 한/영전환된 표현을 잡아낼 수 있습니다. 예를 들면 `시발`의 QWERTY에 대응되는 표현인 `tlqkf`을 잡아낼 수 있습니다.
  1. `isStrong`을 true로 지정하면 다른 문자를 한글자모처럼 이용하는 우회적 표현이나 첫자음 ㅇ, 무의미한 모음 ㅡ삽입 및 된소리를 이용한 우회 표현도 잡아낼 수 있습니다. 특성상 위의 needEnToKo와 같이 사용할 수 없습니다.
